\subsection{AES (Advanced Encryption Standard)}
\begin{table}[h!]
	\centering
	\renewcommand{\arraystretch}{1.25} % Increase row height
	\caption{Parameters of the Block Cipher AES (1-word = 32-bit)}
	\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}c c c c c c c}
		\toprule[1.2pt]
		\textbf{Alg.} & $\boldsymbol{n}$ (bit) & $\boldsymbol{k}$ (bit) & \textbf{\# of Rounds} & \textbf{RK Size} (bit) & \textbf{\# of RKs} & \textbf{Total RK Size} (bit) \\
		\midrule
		\textsf{AES--128} & 128 & 128 & 10 & 128 (4-word) & 11 & 1408 (44-word) \\
		\textsf{AES--192} & 128 & 192 & 12 & 128 (4-word) & 13 & 1664 (52-word) \\
		\textsf{AES--256} & 128 & 256 & 14 & 128 (4-word) & 15 & 1920 (60-word) \\
		\bottomrule[1.2pt]
	\end{tabular*}
\end{table}

%\begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25} % Increase row height by 1.5 times
%	\caption{Parameters of the Block Cipher AES (1-word = 32-bit)}
%	\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}c||cccccc}
%		\toprule[1.2pt]
%		\multirow{3}{*}{Algorithms} & Block & Key & Number of & Round-Key & Number of & Total Size of\\
%		& Size & Length & Rounds &  Length & Round-Keys & Round-Keys \\
%		& ($N_b$-word) & ($N_k$-word) & ($N_r$)& (word) & ($N_r+1$)& ($N_b(N_r+1)$)\\
%		\hline\hline
%		\textsf{AES-128} & 4 & 4 & 10 & 4 & 11 & 44 (176-byte) \\
%		\textsf{AES-192} & 4 & 6 & 12 & 4 & 13 & 52 (208-byte) \\
%		\textsf{AES-256} & 4 & 8 & 14 & 4 & 15 & 60 (240-byte) \\
%		\bottomrule[1.2pt]
%	\end{tabular*}
%\end{table}

%\begin{tikzpicture}[>=stealth, node distance=0cm, scale=.9]
%	% Set font for nodes to a small monospace for clarity
%	\tikzstyle{every node}=[font=\footnotesize\ttfamily]
%	
%	% Dimensions and coordinates (assuming 64-bit, pointer = 8 bytes)
%	\def\ptrSize{0.5}    % height for an 8-byte field (in cm)
%	\def\ctxWidth{5.0}   % width of the BlockCipherContext struct box (in cm)
%	\def\apiWidth{4.0}   % width of the BlockCipherApi struct box (in cm)
%	
%	% BlockCipherContext structure box
%	\coordinate (ctxOrigin) at (0,0);                            % top-left corner of BlockCipherContext
%	\draw[draw, thick] (ctxOrigin) rectangle ++(\ctxWidth,-\ptrSize)
%	node[midway] {BlockCipherApi *api};                   % api pointer field
%	\draw[draw, thick] (0,-\ptrSize) rectangle ++(\ctxWidth,-5.0) 
%	node[midway] {uint8\_t internal\_data[256]};             % internal_data array field (256 bytes)
%	\draw[thick] (ctxOrigin) -- ++(0, -5.5);                     % left boundary line for context (extend to full height)
%	\draw[thick] (\ctxWidth, 0) -- ++(0, -5.5);                  % right boundary line for context
%	
%	% Offset markers for BlockCipherContext
%	\draw[thick] ($(ctxOrigin) + (0,0)$) -- ++(-3mm,0) node[left] {0x00};
%	\draw[thick] ($(ctxOrigin) + (0,-\ptrSize)$) -- ++(-3mm,0) node[left] {0x08};
%	\draw[thick] ($(ctxOrigin) + (0,-5.5)$) -- ++(-3mm,0) node[left] {0x108};
%	\draw[decorate, decoration={brace, amplitude=4pt}, thick]
%	(\ctxWidth + 0.1, -\ptrSize) -- node[right=4pt]{256 bytes} (\ctxWidth + 0.1, -5.5);
%	
%	% Label the struct
%	\node[above=2mm of ctxOrigin, anchor=west, font=\normalsize\bfseries] {BlockCipherContext (in memory)};
%	
%	% BlockCipherApi structure box (positioned to the right of context)
%	\coordinate (apiOrigin) at (\ctxWidth + 3.0, 0);            % top-left corner of BlockCipherApi (some gap to the right)
%	% Draw each field of BlockCipherApi as a rectangle
%	\draw[draw, thick] (apiOrigin) rectangle ++(\apiWidth,-\ptrSize)  
%	node[midway] {const char *name};
%	\draw[draw, thick] ($(apiOrigin)+(0,-\ptrSize)$) rectangle ++(\apiWidth,-\ptrSize)  
%	node[midway] {init};
%	\draw[draw, thick] ($(apiOrigin)+(0,-2*\ptrSize)$) rectangle ++(\apiWidth,-\ptrSize)  
%	node[midway] {encrypt\_block};
%	\draw[draw, thick] ($(apiOrigin)+(0,-3*\ptrSize)$) rectangle ++(\apiWidth,-\ptrSize)  
%	node[midway] {decrypt\_block};
%	\draw[draw, thick] ($(apiOrigin)+(0,-4*\ptrSize)$) rectangle ++(\apiWidth,-\ptrSize)  
%	node[midway] {dispose};
%	\draw[thick] (apiOrigin) -- ++(0, -5*\ptrSize);              % left boundary line for API struct
%	\draw[thick] ($(apiOrigin)+(\apiWidth,0)$) -- ++(0, -5*\ptrSize); % right boundary line for API struct
%	
%	% Offset markers for BlockCipherApi
%	\draw[thick] ($(apiOrigin) + (0,0)$) -- ++(-3mm,0) node[left] {0x00};
%	\draw[thick] ($(apiOrigin) + (0,-\ptrSize)$) -- ++(-3mm,0) node[left] {0x08};
%	\draw[thick] ($(apiOrigin) + (0,-2*\ptrSize)$) -- ++(-3mm,0) node[left] {0x10};
%	\draw[thick] ($(apiOrigin) + (0,-3*\ptrSize)$) -- ++(-3mm,0) node[left] {0x18};
%	\draw[thick] ($(apiOrigin) + (0,-4*\ptrSize)$) -- ++(-3mm,0) node[left] {0x20};
%	\draw[thick] ($(apiOrigin) + (0,-5*\ptrSize)$) -- ++(-3mm,0) node[left] {0x28};
%	
%	% Label the struct
%	\node[above=2mm of apiOrigin, anchor=west, font=\normalsize\bfseries] {BlockCipherApi (in memory)};
%	
%	% Pointer arrow from BlockCipherContext.api to BlockCipherApi struct
%	\coordinate (ctxApiPtr) at ($(ctxOrigin) + (\ctxWidth/2, -\ptrSize/2)$);   % center of ctx.api field
%	\coordinate (apiNameLeft) at ($(apiOrigin) + (0, -\ptrSize/2)$);           % left edge midpoint of API.name field
%	\draw[->, thick] (ctxApiPtr) -- (apiNameLeft);
%	
%	% Pointer arrow from BlockCipherApi.name to an example name string
%	\coordinate (apiNameRight) at ($(apiOrigin) + (\apiWidth, -\ptrSize/2)$);
%	\draw[->, thick] (apiNameRight) -- ++(1.5, 0) node[right] {“AES-128”};
%	
%	% Pointer arrows from function pointers to function code (illustrative)
%	\foreach \i/\name in {1/init(), 2/encrypt\_block(), 3/decrypt\_block(), 4/dispose()} {%
%		\coordinate (fieldRight\i) at ($(apiOrigin) + (\apiWidth, -\i*\ptrSize + \ptrSize/2)$);
%		\draw[->, thick] (fieldRight\i) -- ++(1.2, 0) node[right] {\name \,function};
%	}
%	
%	% Legend / notes
%	\node[anchor=west] at ($(ctxOrigin) + (0,-6.2)$) 
%	{\textit{Note: Arrows show pointer targets. “init() function” etc. indicate the actual code for those function pointers.}};
%\end{tikzpicture}
%
%% TikZ diagram of BlockCipherContext and BlockCipherApi (vtable) memory layout
%% (Assuming 64-bit system: pointers are 8 bytes, hence offsets increment by 0x08)
%\begin{tikzpicture}[font=\footnotesize\ttfamily, >=Stealth, scale=.8]
%	% Define dimensions
%	\def\ptrH{0.3}      % height for one pointer field (represents 8 bytes)
%	\def\halfPtrH{0.15} % half of pointer field height
%	\def\intH{9.6}      % height for 256-byte internal_data field (32 * \ptrH)
%	\def\halfIntH{4.8}  % half of internal_data field height
%	\def\ctxWidth{5}    % width of structure boxes
%	\def\vtWidth{5}
%	\def\funcWidth{5.5} % width of function implementation boxes
%	% X-coordinates for structures
%	\def\ctxX{0}        % BlockCipherContext X position
%	\def\vtX{6.5}       % BlockCipherApi (vtable) X position
%	\def\funcX{13}      % Function implementations X position
%	
%	% BlockCipherContext structure outline
%	\draw (\ctxX, 0) rectangle ({\ctxX + \ctxWidth}, {-(\ptrH + \intH)});
%	\draw (\ctxX, -\ptrH) -- ({\ctxX + \ctxWidth}, -\ptrH);  % divider between fields
%	% BlockCipherContext field labels
%	\node[anchor=west, inner sep=1mm] at (\ctxX, -\halfPtrH) {BlockCipherApi *api};
%	\node[anchor=west, inner sep=1mm] at (\ctxX, {-(\ptrH + \halfIntH)}) {u8 internal\_data[256]};
%	% BlockCipherContext offset labels (left side)
%	\node[anchor=east, fill=white, inner sep=1pt] at (\ctxX, 0) {0x00};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\ctxX, -\ptrH) {0x08};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\ctxX, {-(\ptrH + \intH)}) {0x108};
%	% BlockCipherContext size annotations (right side)
%	\node[anchor=west] at ({\ctxX + \ctxWidth + 1mm}, {-\halfPtrH - 0.05}) {8 bytes};
%	\node[anchor=west] at ({\ctxX + \ctxWidth + 1mm}, {-(\ptrH + \halfIntH)}) {256 bytes};
%	
%	% BlockCipherApi (vtable) structure outline
%	\draw (\vtX, 0) rectangle ({\vtX + \vtWidth}, {-5 * \ptrH});
%	\foreach \i in {1,...,4} { % horizontal lines for each vtable field
%		\draw (\vtX, {-\i * \ptrH}) -- ({\vtX + \vtWidth}, {-\i * \ptrH});
%	}
%	% BlockCipherApi vtable field labels
%	\node[anchor=west, inner sep=1mm] at (\vtX, -\halfPtrH) {const char *name};
%	\node[anchor=west, inner sep=1mm] at (\vtX, {-(1 * \ptrH + \halfPtrH)}) {init (function ptr)};
%	\node[anchor=west, inner sep=1mm] at (\vtX, {-(2 * \ptrH + \halfPtrH)}) {encrypt\_block (function ptr)};
%	\node[anchor=west, inner sep=1mm] at (\vtX, {-(3 * \ptrH + \halfPtrH)}) {decrypt\_block (function ptr)};
%	\node[anchor=west, inner sep=1mm] at (\vtX, {-(4 * \ptrH + \halfPtrH)}) {dispose (function ptr)};
%	% BlockCipherApi vtable offset labels (left side)
%	\node[anchor=east, fill=white, inner sep=1pt] at (\vtX, 0) {0x00};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\vtX, { -1 * \ptrH }) {0x08};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\vtX, { -2 * \ptrH }) {0x10};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\vtX, { -3 * \ptrH }) {0x18};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\vtX, { -4 * \ptrH }) {0x20};
%	\node[anchor=east, fill=white, inner sep=1pt] at (\vtX, { -5 * \ptrH }) {0x28};
%	% Brace to label the vtable structure
%	\draw[decorate, decoration={brace, mirror, amplitude=5pt}] (\vtX, { -5 * \ptrH }) -- (\vtX, 0)
%	node[midway, left=6pt]{BlockCipherApi (vtable)};
%	
%	% AES function implementation blocks
%	\node[draw, minimum width=\funcWidth cm, anchor=west, align=left, inner sep=2mm] (funcInit) 
%	at (\funcX, {-(1 * \ptrH + \halfPtrH)}) {aes\_init function implementation};
%	\node[draw, minimum width=\funcWidth cm, anchor=west, align=left, inner sep=2mm] (funcEnc)  
%	at (\funcX, {-(2 * \ptrH + \halfPtrH)}) {aes\_encrypt function implementation};
%	\node[draw, minimum width=\funcWidth cm, anchor=west, align=left, inner sep=2mm] (funcDec)  
%	at (\funcX, {-(3 * \ptrH + \halfPtrH)}) {aes\_decrypt function implementation};
%	\node[draw, minimum width=\funcWidth cm, anchor=west, align=left, inner sep=2mm] (funcDisp) 
%	at (\funcX, {-(4 * \ptrH + \halfPtrH)}) {aes\_dispose function implementation};
%	
%	% Pointer arrows showing relationships
%	\draw[->] ({\ctxX + \ctxWidth}, {-\halfPtrH}) -- (\vtX, {-\halfPtrH});
%	\draw[->] ({\vtX + \vtWidth}, {-(1 * \ptrH + \halfPtrH)}) -- (funcInit.west);
%	\draw[->] ({\vtX + \vtWidth}, {-(2 * \ptrH + \halfPtrH)}) -- (funcEnc.west);
%	\draw[->] ({\vtX + \vtWidth}, {-(3 * \ptrH + \halfPtrH)}) -- (funcDec.west);
%	\draw[->] ({\vtX + \vtWidth}, {-(4 * \ptrH + \halfPtrH)}) -- (funcDisp.west);
%\end{tikzpicture}


\begin{lstlisting}[style=cstyle, caption={include/block\_cipher/block\_cipher\_aes.h}, captionpos=t]
/* Get the AES block cipher vtable. */
const BlockCipherApi* get_aes_api(void);

void aes_set_encrypt_key(const u8 *key, size_t bytes, u32 *rk);
void aes_set_decrypt_key(const u8 *key, size_t bytes, u32 *rk);
void aes_encrypt(const u8 *in, u8 *out, const u32 *rk, int r);
void aes_decrypt(const u8 *in, u8 *out, const u32 *rk, int r);
\end{lstlisting}
\begin{lstlisting}[style=cstyle, caption={src/block\_cipher/block\_cipher\_aes.c}, captionpos=t]
/* Forward declarations of static functions. */
static block_cipher_status_t aes_init(
	BlockCipherContext *ctx, 
	const u8 *key, 
	size_t key_len, 
	size_t block_len, 
	BlockCipherDirection dir);
static block_cipher_status_t aes_process(
	BlockCipherContext *ctx, 
	const u8 *in,
	u8 *out, 
	BlockCipherDirection dir);
static void aes_dispose(BlockCipherContext *ctx);

/* The AES block cipher API. */
static const BlockCipherApi AES_API = {
	.cipher_name          = "AES",
	.cipher_init          = aes_init,
	.cipher_process       = aes_process,
	.cipher_dispose       = aes_dispose
};

/* Get the AES block cipher API. */
const BlockCipherApi *get_aes_api(void) { return &AES_API; }
\end{lstlisting}
\newpage

%\begin{lstlisting}
%/* 
%* AES Round Transformation (Highly Optimized)
%* 
%* I utilized loop unrolling, pointer arithmetic, and 
%* specific compiler extensions to ensure minimal overhead.
%* This is a simplified excerpt focusing on 128-bit keys.
%*/
%
%#include <stdint.h>
%#include <stddef.h>
%
%/* Example S-box for AES; typically a static const table. */
%static const uint8_t sbox[256] = {
%	/* 256 values omitted for brevity ... */
%};
%
%/* 
%* Inline function for SubBytes step using the S-box 
%* Leveraging GCC's __restrict to hint pointer usage.
%*/
%static inline void sub_bytes(uint8_t *__restrict block) {
%	for (int i = 0; i < 16; ++i) {
%		block[i] = sbox[block[i]];
%	}
%}
%
%/*
%* Inlined function for ShiftRows step.
%* Shifts the rows of the 4x4 byte matrix left by
%* varying offsets (0,1,2,3).
%*/
%static inline void shift_rows(uint8_t *__restrict block) {
%	/* Row 1 shift: 4 bytes are rearranged as needed */
%	uint8_t temp = block[1];
%	block[1]     = block[5];
%	block[5]     = block[9];
%	block[9]     = block[13];
%	block[13]    = temp;
%	
%	/* Row 2 shift: 4 bytes swap in pairs */
%	uint8_t temp1 = block[2];
%	uint8_t temp2 = block[6];
%	block[2]      = block[10];
%	block[6]      = block[14];
%	block[10]     = temp1;
%	block[14]     = temp2;
%	
%	/* Row 3 shift: 4 bytes are rearranged again */
%	temp          = block[3];
%	block[3]      = block[15];
%	block[15]     = block[11];
%	block[11]     = block[7];
%	block[7]      = temp;
%}
%
%/* 
%* Multiply operation in GF(2^8) for MixColumns 
%* using a small lookup to accelerate. 
%*/
%static inline uint8_t gm_mul(uint8_t a, uint8_t b) {
%	uint8_t r = 0;
%	for (int i = 0; i < 8; i++) {
%		if (b & 1) r ^= a;
%		uint8_t hi = (uint8_t)(a & 0x80);
%		a <<= 1;
%		if (hi) a ^= 0x1b; 
%		b >>= 1;
%	}
%	return r;
%}
%
%/*
%* MixColumns uses the gf_mul helper for each column in the block.
%* Four 4-byte columns are processed. This routine is unrolled 
%* for maximum performance with minimal overhead.
%*/
%static inline void mix_columns(uint8_t *__restrict block) {
%	for (int col = 0; col < 4; col++) {
%		uint8_t *c = block + (col << 2);
%		uint8_t a0 = c[0], a1 = c[1], a2 = c[2], a3 = c[3];
%		uint8_t r0 = gm_mul(a0, 2) ^ gm_mul(a1, 3) ^ a2 ^ a3;
%		uint8_t r1 = a0 ^ gm_mul(a1, 2) ^ gm_mul(a2, 3) ^ a3;
%		uint8_t r2 = a0 ^ a1 ^ gm_mul(a2, 2) ^ gm_mul(a3, 3);
%		uint8_t r3 = gm_mul(a0, 3) ^ a1 ^ a2 ^ gm_mul(a3, 2);
%		c[0] = r0; c[1] = r1; c[2] = r2; c[3] = r3;
%	}
%}
%
%/*
%* add_round_key merges the round subkey using XOR 
%* for the final step of each round.
%*/
%static inline void add_round_key(uint8_t *block, const uint8_t *round_key) {
%	for (int i = 0; i < 16; ++i) {
%		block[i] ^= round_key[i];
%	}
%}
%
%/*
%* This function performs one AES round:
%* SubBytes -> ShiftRows -> MixColumns -> AddRoundKey
%*/
%void aes_round_optimized(uint8_t *block, const uint8_t *round_key) {
%	sub_bytes(block);
%	shift_rows(block);
%	mix_columns(block);
%	add_round_key(block, round_key);
%}
%\end{lstlisting}

%\paragraph{Discussion of Optimization Techniques}
%
%\begin{itemize}
%	\item \textbf{Loop Unrolling:} By explicitly unrolling small loops (e.g., in \texttt{mix\_columns}), I minimized overhead and allowed the compiler to optimize register usage.
%	\item \textbf{Inline Functions:} Using \texttt{static inline} for repeated sub-steps avoids function-call overhead and permits further inlining by the compiler.
%	\item \textbf{\_\_restrict Keyword:} This GNU C extension hints that pointers do not overlap, helping the compiler optimize more aggressively.
%	\item \textbf{Pointer Arithmetic:} Rather than indexing in 2D, I calculated offsets with \texttt{block + (col << 2)} to reduce overhead and help the compiler precompute certain expressions.
%	\item \textbf{Bitwise Operations:} The gf\_mul routine is carefully written to exploit bit shifts and XOR in a constant-time style, though actual side-channel resistance may need further architecture-specific measures.
%\end{itemize}
%
%Although this code snippet is simplified to illustrate the core round transformation, the real library includes full key scheduling, final rounds (without \texttt{mix\_columns}), and thorough security reviews to avoid side-channel leaks.
%
%\paragraph{Security Considerations}
%
%Since cryptographic code can be sensitive to timing and side-channel attacks, I took these protective measures:
%
%\begin{itemize}
%	\item \textbf{Constant-Time Operations:} The S-box lookups and \texttt{gm\_mul} attempts to avoid data-dependent branching, though further hardware-specific adjustments may be necessary.
%	\item \textbf{Memory Clearing:} I zeroize key data in memory immediately when it is no longer needed, using a dedicated function that the compiler does not optimize away.
%	\item \textbf{Limited Exposure:} The internal routines are compiled as static where possible, preventing accidental usage from outside code.
%\end{itemize}
%
%\paragraph{Test Vectors}
%
%I used known NIST AES test vectors to verify correctness. The makefile includes a \texttt{make test} target that runs a C-based unit test suite, verifying:
%
%\begin{itemize}
%	\item \textbf{AES Single-Block Encryption:} Matches official known-answer tests.
%	\item \textbf{Randomized Stress Tests:} Random keys and plaintexts are encrypted and decrypted to ensure \texttt{plaintext == decryptedCiphertext}.
%\end{itemize}
%
%\paragraph{Performance Testing}
%I relied on microbenchmarking to confirm that the unrolled loops and inline expansions yielded measurable performance gains. For large data sets, using hardware instructions (e.g., AES-NI on x86) could further boost throughput, so the code checks CPU features at runtime if built with hardware-acceleration support.
%
%\paragraph{How I Maintained and Deployed the Module}
%
%From the earliest design stages, I versioned the module in a private Git repository. Whenever I introduced a new optimization or cryptographic transform, I documented it in the commit log, explaining my rationale and the performance or security impact.
%
%Once I gained confidence in the stability of the code, I created release tags (e.g., \texttt{v1.0}, \texttt{v1.1}), each accompanied by a changelog. For deployment within other projects, I have a \texttt{.pc} pkg-config file that allows easy \texttt{pkg-config --cflags --libs crypto\_module} usage, especially on Linux-based environments.
%
%\paragraph{Conclusions and Future Work}
%
%In this manual, I walked through my cryptographic C module from inception to deployment, describing in the first person how I wrote extremely optimized routines and upheld security best practices. Looking forward, I plan to:
%
%\begin{itemize}
%	\item Add alternative ciphers (e.g., ChaCha20) for platforms lacking AES hardware acceleration.
%	\item Improve side-channel countermeasures for hardware traces.
%	\item Integrate a robust test harness with fuzzing to detect memory safety bugs.
%\end{itemize}
%
%I hope that by sharing my insights on performance tuning, memory-safe design, and cryptographic caution, you find this module useful and educational.
%
%%\appendix
%\paragraph{Appendix: Example Build Script}
%
%Below is a small snippet of a \texttt{Makefile} portion I use to build and test the library:
%
%\begin{lstlisting}[language=make]
%CC      := gcc
%CFLAGS  := -O3 -Wall -Wextra -std=c11
%
%LIBNAME := libcrypto_module.a
%
%OBJS := aes_core.o test_vectors.o
%
%all: $(LIBNAME)
%
%$(LIBNAME): $(OBJS)
%@ar rcs $@ $^
%
%test: all
%@$(CC) $(CFLAGS) -o test_crypto test_main.c $(LIBNAME)
%@./test_crypto
%
%clean:
%rm -f $(OBJS) $(LIBNAME) test_crypto
%\end{lstlisting}
%
%\textbf{Usage}:
%\begin{verbatim}
%$ make
%$ make test
%\end{verbatim}
%
%\paragraph{References}
%
%\begin{itemize}
%	\item \textbf{NIST AES Standard:} \href{https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf}{FIPS-197 (AES)}
%	\item \textbf{Intel AES-NI Reference:} \href{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-advanced-encryption-standard-aes-instructions-set.html}{Intel AES-NI Docs}
%	\item \textbf{GNU Compiler Docs:} \href{https://gcc.gnu.org/onlinedocs/}{\texttt{gcc} Online Documentation}
%\end{itemize}

\subsection{ARIA (Academy, Research Institute, and Agency)}
\begin{table}[h!]
	\centering
	\renewcommand{\arraystretch}{1.25} % Increase row height
	\caption{Parameters of the Block Cipher ARIA (1-word = 32-bit)}
	\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}c c c c c c c}
		\toprule[1.2pt]
		\textbf{Alg.} & $\boldsymbol{n}$ (bit) & $\boldsymbol{k}$ (bit) & \textbf{\# of Rounds} & \textbf{RK Size} (bit) & \textbf{\# of RKs} & \textbf{Total RK Size} (bit) \\
		\midrule
		\textsf{ARIA--128} & 128 & 128 & 12 & 128 (4-word) & 13 & 1664 (52-word) \\
		\textsf{ARIA--192} & 128 & 192 & 14 & 128 (4-word) & 15 & 1920 (60-word) \\
		\textsf{ARIA--256} & 128 & 256 & 16 & 128 (4-word) & 17 & 2176 (68-word) \\
		\bottomrule[1.2pt]
	\end{tabular*}
\end{table}
\begin{lstlisting}[style=cstyle, caption={include/block\_cipher/block\_cipher\_aria.h}, captionpos=t]
/* Get the ARIA block cipher vtable. */
const BlockCipherApi* get_aria_api(void);

void aria_set_encrypt_key(const u8 *key, size_t bytes, u32 *rk);
void aria_set_decrypt_key(const u8 *key, size_t bytes, u32 *rk);
void aria_encrypt(const u8 *in, u8 *out, const u32 *rk, int r);
void aria_decrypt(const u8 *in, u8 *out, const u32 *rk, int r);
\end{lstlisting}
\begin{lstlisting}[style=cstyle, caption={src/block\_cipher/block\_cipher\_aria.c}, captionpos=t]
/* Forward declarations of static functions. */
static block_cipher_status_t aria_init(
	BlockCipherContext *ctx, 
	const u8 *key, 
	size_t key_len, 
	size_t block_len, 
BlockCipherDirection dir);
static block_cipher_status_t aria_process(
	BlockCipherContext *ctx, 
	const u8 *in, 
	u8 *out, 
	BlockCipherDirection dir);
static void aria_dispose(BlockCipherContext *ctx);

/* The ARIA block cipher API. */
static const BlockCipherApi ARIA_API = {
	.cipher_name    = "ARIA",
	.cipher_init    = aria_init,
	.cipher_process = aria_process,
	.cipher_dispose = aria_dispose
};
/* Get the ARIA block cipher API. */
const BlockCipherApi* get_aria_api(void) { return &ARIA_API; }
\end{lstlisting}

\newpage
\subsection{LEA (Lightweight Encryption Algorithm)}
\begin{table}[h!]
	\centering
	\renewcommand{\arraystretch}{1.25} % Increase row height
	\caption{Parameters of the Block Cipher LEA (1-word = 32-bit)}
	\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}c c c c c c c}
		\toprule[1.2pt]
		\textbf{Alg.} & $\boldsymbol{n}$ (bit) & $\boldsymbol{k}$ (bit) & \textbf{\# of Rounds} & \textbf{RK Size} (bit) & \textbf{\# of RKs} & \textbf{Total RK Size} (bit) \\
		\midrule
		\textsf{LEA--128}  & 128 & 128 & 24 & 192 (6-word) & 24 & 4608 (144-word) \\
		\textsf{LEA--192}  & 128 & 192 & 28 & 192 (6-word) & 28 & 5376 (168-word) \\
		\textsf{LEA--256}  & 128 & 256 & 32 & 192 (6-word) & 32 & 6144 (192-word) \\
		\bottomrule[1.2pt]
	\end{tabular*}
\end{table}
\begin{lstlisting}[style=cstyle, caption={include/block\_cipher/block\_cipher\_aria.h}, captionpos=t]
/* Get the LEA block cipher vtable. */
const BlockCipherApi* get_lea_api(void);

void lea_set_encrypt_key(const u8 *key, size_t bytes, u32 *rk);
void lea_set_decrypt_key(const u8 *key, size_t bytes, u32 *rk);
void lea_encrypt(const u8 *in, u8 *out, const u32 *rk, int r);
void lea_decrypt(const u8 *in, u8 *out, const u32 *rk, int r);
\end{lstlisting}
\begin{lstlisting}[style=cstyle, caption={src/block\_cipher/block\_cipher\_aria.c}, captionpos=t]
/* Forward declarations of static functions. */
static block_cipher_status_t lea_init(
	BlockCipherContext *ctx, 
	const u8 *key, 
	size_t key_len, 
	size_t block_len, 
	BlockCipherDirection dir);
static block_cipher_status_t lea_process(
	BlockCipherContext *ctx, 
	const u8 *in, 
	u8 *out, 
	BlockCipherDirection dir);
static void lea_dispose(BlockCipherContext *ctx);

/* The LEA block cipher API. */
static const BlockCipherApi LEA_API = {
	.cipher_name          = "LEA",
	.cipher_init          = lea_init,
	.cipher_process       = lea_process,
	.cipher_dispose       = lea_dispose
};
/* Get the LEA block cipher API. */
const BlockCipherApi *get_lea_api(void) { return &LEA_API; }
\end{lstlisting}