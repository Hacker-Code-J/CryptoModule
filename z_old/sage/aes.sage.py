

# This file was *autogenerated* from the file aes.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_16 = Integer(16); _sage_const_1 = Integer(1); _sage_const_32 = Integer(32); _sage_const_0 = Integer(0); _sage_const_9 = Integer(9); _sage_const_10 = Integer(10); _sage_const_0x00000000a58869d74be5a374cf867cfb = Integer(0x00000000a58869d74be5a374cf867cfb); _sage_const_0x00000000000000000000000000000000 = Integer(0x00000000000000000000000000000000)
from sage.crypto.mq.rijndael_gf import RijndaelGF
from binascii import unhexlify, hexlify
import os

class AES():
    def __init__(self, key):
        self.rijndaelGF = RijndaelGF(_sage_const_4 , _sage_const_4 )
        self.hex2GF = lambda pt: self.rijndaelGF._hex_to_GF(pt)
        self.GF2hex = lambda ct: self.rijndaelGF._GF_to_hex(ct)
        self.add_round_key = lambda state, i: state + self.subkeys[i]
        self.subkeys = self.rijndaelGF.expand_key(self.hex2GF(hexlify(key).decode()))

    def pad(self, pt):
        pad_len = _sage_const_16  - (len(pt) % _sage_const_16 )
        return pt + bytes([pad_len] * pad_len)

    def unpad(self, ct):
        return ct[:-ct[-_sage_const_1 ]]

    def enc_bloc(self, pt):
        assert len(pt) == _sage_const_32 
        state = self.hex2GF(pt)
        state = self.add_round_key(state, _sage_const_0 )
        for i in range(_sage_const_9 ):
            state = self.rijndaelGF.sub_bytes(state)
            state = self.rijndaelGF.shift_rows(state)
            state = self.rijndaelGF.mix_columns(state)
            state = self.add_round_key(state, i + _sage_const_1 )
        state = self.rijndaelGF.sub_bytes(state)
        state = self.rijndaelGF.shift_rows(state)
        state = self.add_round_key(state, _sage_const_10 )
        return self.GF2hex(state)

    def dec_bloc(self, ct):
        assert len(ct) == _sage_const_32 
        state = self.hex2GF(ct)
        state = self.add_round_key(state, _sage_const_10 )
        state = self.rijndaelGF.shift_rows(state, algorithm='decrypt')
        state = self.rijndaelGF.sub_bytes(state, algorithm='decrypt')
        for i in range(_sage_const_9 , _sage_const_0 , -_sage_const_1 ):
            state = self.add_round_key(state, i)
            state = self.rijndaelGF.mix_columns(state, algorithm='decrypt')
            state = self.rijndaelGF.shift_rows(state, algorithm='decrypt')
            state = self.rijndaelGF.sub_bytes(state, algorithm='decrypt')
        state = self.add_round_key(state, _sage_const_0 )
        return self.GF2hex(state)

    def encrypt(self, ct):
        # ECB Mod because i'am lazy
        ct = hexlify(self.pad(ct)).decode()
        blocs = [ct[_sage_const_32  * i:_sage_const_32  * (i + _sage_const_1 )] for i in range(len(ct) // _sage_const_32 )]
        return unhexlify(bytes(''.join([self.enc_bloc(b) for b in blocs]), 'utf-8'))

    def decrypt(self, pt):
        pt = hexlify(pt).decode()
        blocs = [pt[_sage_const_32  * i:_sage_const_32  * (i + _sage_const_1 )] for i in range(len(pt) // _sage_const_32 )]
        return self.unpad(unhexlify(bytes(''.join([self.dec_bloc(b) for b in blocs]), 'utf-8')))


# Input key from user
# key_input = input("Enter a 16-byte key in hexadecimal format (32 hex characters): ")
# if len(key_input) != 32:
#     raise ValueError("Key must be 16 bytes (32 hex characters).")
# key = unhexlify(key_input)
key = int(_sage_const_0x00000000a58869d74be5a374cf867cfb ).to_bytes(_sage_const_16 , byteorder='big')

engine = AES(key)
plaintext = int(_sage_const_0x00000000000000000000000000000000 ).to_bytes(_sage_const_16 , byteorder='big')
ct = engine.encrypt(plaintext)
pt = engine.decrypt(ct)

assert pt == plaintext

print("Plaintext  (hex):", plaintext.hex())
print("Ciphertext (hex):", ct.hex())
print("Decrypted  (hex):", pt.hex())

